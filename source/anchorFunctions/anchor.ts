import * as vscode from 'vscode';
import Annotation from '../constants/constants';
import { v4 as uuidv4 } from 'uuid';
import { buildAnnotation } from '../utils/utils';
import { annotationList, user, tabSize as userTabSize, deletedAnnotations, setDeletedAnnotationList, annotationDecorations } from '../extension';


function getIndicesOf(searchStr: string, str: string, caseSensitive: boolean) {
    var searchStrLen = searchStr.length;
    if (searchStrLen == 0) {
        return [];
    }
    var startIndex = 0, index, indices = [];
    if (!caseSensitive) {
        str = str.toLowerCase();
        searchStr = searchStr.toLowerCase();
    }
    while ((index = str.indexOf(searchStr, startIndex)) > -1) {
        indices.push(index);
        startIndex = index + searchStrLen;
    }
    return indices;
}


export const getAnchorsInRange = (selection: vscode.Selection, annotationList: Annotation[]) : {[key: string] : any}[] => {
	return annotationList.map(a =>{ return { id: a.id, range: createRangeFromAnnotation(a) } }).filter(a => selection.contains(a.range));
}

// computes boundary points of each annotation's range given the pasted new range
export const splitRange = (range: vscode.Range, annotationList: Annotation[], filename: string, changeText: string) : Annotation[] => {
	let annoRanges = annotationList.map(a =>{ return {id: a.id, range: createRangeFromAnnotation(a), anchorText: a.anchorText }});
	// ensure first range in list is the beginning boundary range
	annoRanges = annoRanges.sort((a, b) => {
		return a.range.start.line - b.range.start.line;
	});

	annoRanges = annoRanges.map((a: any, index: number) => {
		let r = a.range;
		let numLines = r.end.line - r.start.line;
		let startOffset = r.start.character;
		let endOffset = r.end.character;
		const lastRange = index > 0 ? annoRanges[index - 1].range : r;
		const cleanAnchorText = a.anchorText.split(' ').join('');
		const cleanChangeText = changeText.split(' ').join('');
		const stringUntilAnchorText = cleanChangeText.substring(0, cleanChangeText.indexOf(cleanAnchorText));
		const numLinesBeforeAnchorStart = (stringUntilAnchorText.match(/\n/g) || []).length;
		// first range
		if(index === 0) {
			let newRange = { id: a.id, range: new vscode.Range(new vscode.Position(range.start.line + numLinesBeforeAnchorStart, range.start.character), new vscode.Position(range.start.line + numLines + numLinesBeforeAnchorStart, endOffset)), anchorText: a.anchorText};
			return newRange;
		}
		// last range
		else if(index === annoRanges.length - 1) {
			return {id: a.id, range: new vscode.Range(new vscode.Position(range.end.line - numLines,  startOffset), range.end), anchorText: a.anchorText};
		}
		// middle ranges
		else {
			return {id: a.id, range: new vscode.Range(
				new vscode.Position(lastRange?.end.line, lastRange?.end.character + startOffset), 
				new vscode.Position(lastRange?.end.line + numLines, endOffset)),
			anchorText: a.anchorText} 
		}
	});

	const rangeAdjustedAnnotations = annotationList.map(a => {
		const index = annoRanges.findIndex(r => r.id === a.id);
		const annoRange = annoRanges[index].range;
		return buildAnnotation(a, annoRange);
	});
	return rangeAdjustedAnnotations;
}

// const findFirstIndexInString = (matchingString: string, stringArr: string[]) : number => {
// 	const stringArr.
// }

export const findAnchorInRange = (range: vscode.Range, anchor: string, doc: vscode.TextDocument, changeText: string, anchorLength: number, isSingleLine: boolean) : {[key: string] : any} => {
	const tokenizedRange = changeText.split(/\s+/g);
	console.log('tokenized', tokenizedRange);
	const tokenizedAnchorWhitespace = anchor.split(/\s+/g); 
	console.log('tokenized anchor', tokenizedAnchorWhitespace);
	const cleanFrontAnchor = anchor.trimStart();
	const cleanBackAnchor = anchor.trimEnd();
	const tokenizedAnchor = cleanFrontAnchor.split(/\s+/g);
	const firstElOfAnchor = tokenizedAnchor[0];
	console.log('first el', firstElOfAnchor);
	const tokenizedBackAnchor = cleanBackAnchor.split(/\s+/g);
	const lastEl = tokenizedBackAnchor[tokenizedBackAnchor.length - 1];

	let tokenStart = 0;
	let tokenEnd = 0;
	tokenizedRange.forEach((t: string, index: number) => {
		if(t === firstElOfAnchor) {
			let i = index;
			let j = 0;
			while(tokenizedRange[i] && tokenizedAnchorWhitespace[j] && tokenizedRange[i] === tokenizedAnchorWhitespace[j]) {
				// console.log('in while - change', tokenizedRange[i], 'anchor', tokenizedAnchorWhitespace[j])
				if(tokenizedRange[i] === lastEl) {
					tokenStart = index;
					tokenEnd = i;
					break;
				}
				i++;
				j++;
			}
		}
	});

	if(!tokenStart && !tokenEnd) {
		console.log('no match');
		// put in some return here - either obj generated by hackier solution or some default obj
	}

	// console.log('tokenStart', tokenStart);
	// console.log('tokenEnd', tokenEnd);
	// console.log('first token', tokenizedRange[tokenStart])
	// console.log('last token', tokenizedRange[tokenEnd])
	// console.log('anchor length', anchor.length)
	// console.log('change string first index', changeText.indexOf(tokenizedRange[tokenEnd]) - anchor.length < 0 ? changeText.indexOf(tokenizedRange[tokenStart]) : changeText.indexOf(tokenizedRange[tokenEnd]) - anchor.length)
	// console.log('change string last index', changeText.indexOf(tokenizedRange[tokenEnd]))

	let stringStart: number = 0;
	let stringEnd: number = 0;
	const rejoinedString = tokenizedRange.slice(tokenStart, tokenEnd + 1);
	const candidateMatches = getIndicesOf(tokenizedRange[tokenStart], changeText, true);
	// console.log('candidates', candidateMatches);
	// console.log('rejoined', rejoinedString);
	if(candidateMatches.length) {
		let index: number = 0
		// look at next word and see if it appears after one of our indices
		// -- repeat until all options are ruled out except one
		const candidateAnchors = candidateMatches.map((index: number) => {return { index, arr: changeText.substring(index, index + anchor.length).split(/\s+/g) }});
		// console.log('candidateAnchors', candidateAnchors);
		const checkIfWeFoundIt = candidateAnchors.filter((obj) => obj.arr.length === rejoinedString.length)
		if(checkIfWeFoundIt.length === 1) {
			stringStart = checkIfWeFoundIt[0].index;
			stringEnd = checkIfWeFoundIt[0].index + anchor.length;
		}
		else {
			let numMatches : number[] = [];
			// I'm 100000% sure there's a better way to do this LMAO
			candidateAnchors.forEach((obj: {[key: string] : any}) => {
				console.log('obj', obj);
				for(let i = 0; i < obj.arr.length; i++) {
					console.log('candidate', obj.arr[i], 'rejoined', rejoinedString[i]);
					if(obj.arr[i] !== rejoinedString[i]) {
						numMatches.push(i);
						return;
					}
				}
			});
			console.log('num matches', numMatches);
			index = numMatches.indexOf(Math.max(...numMatches)) === -1 ? 0 : numMatches.indexOf(Math.max(...numMatches));
			console.log('index', index);
			stringStart = candidateAnchors[index].index;
			stringEnd = candidateAnchors[index].index + anchor.length;
		}
	}
	else {
		stringEnd = changeText.indexOf(tokenizedRange[tokenEnd]) + tokenizedRange[tokenEnd].length;
		stringStart = stringEnd - anchor.length < 0 ? changeText.indexOf(tokenizedRange[tokenStart]) : stringEnd - anchor.length;
	}

	// const comparatorString = compare.replace()
	// const stringEnd : number = changeText.indexOf(tokenizedRange[tokenEnd]) + tokenizedRange[tokenEnd].length;
	// const stringStart : number = stringEnd - anchor.length < 0 ? changeText.indexOf(tokenizedRange[tokenStart]) : stringEnd - anchor.length;
	
	// console.log('tokenStart', tokenStart);
	// console.log('tokenEnd', tokenEnd);
	// console.log('first token', tokenizedRange[tokenStart])
	// console.log('last token', tokenizedRange[tokenEnd])
	// console.log('anchor length', anchor.length)
	// console.log('change string first index', stringStart)
	// console.log('change string last index', stringEnd)
	
	
	const splice : string = changeText.substring(stringStart, stringEnd); // might not even need this ?
	// console.log('splice', splice);
	const lastSearchString : string = splice.substring(splice.lastIndexOf('\n'));
	let startOffset = 0;
	let endOffset = 0;
	let precedingLines = 0;
	let s = stringStart;
	if(changeText.includes('\n')) {
		if(!(s === 0 || changeText[s - 1] === '\n')) {
			while(changeText[s] && changeText[s] !== '\n') {
				s--;
			}
			startOffset = stringStart - s;
		}
		endOffset = lastSearchString.length;
		precedingLines = (changeText.substring(0, stringStart).match(/\n/g) || []).length;
	}
	else {
		startOffset = stringStart; // need to add difference in length between this and changetext
		endOffset = stringEnd;
	}
	// console.log('changeText[s]', changeText[s], 's', s)
	
	

	// console.log('lastSearchString', lastSearchString);
	// console.log('splice', splice);


	const newAnchor = {
		startLine: range.start.line + precedingLines,
		startOffset,
		endLine: range.start.line + precedingLines + anchorLength,
		endOffset
	}

	console.log('new anchor', newAnchor);
	return newAnchor;


	// // console.log('splce', splice);

	// let numLinesStart = 0;
	// let numCharactersStart = 0;
	// let numCharactersEnd = 0;
	// let tabSize = 4;
	// if(userTabSize && typeof userTabSize === 'number') {
	// 	tabSize = userTabSize;
	// }

	// if(isSingleLine) {
	// 	const substr = changeText.substring(0, changeText.indexOf(tokenizedAnchor[0]));
	// 	numLinesStart = substr.includes('\n') ? (substr.match(/\n/g) || []).length : 0;
	// 	for(let i = 0; i < substr.length; i++) {
	// 		switch(substr[i]) {
	// 			case ('\t'):
	// 				numCharactersStart += tabSize; // may need to get tab size from vscode somehow
	// 				break;
	// 			case ('\r'):
	// 				break;
	// 			default:
	// 				numCharactersStart++;
	// 				break;
	// 		}
	// 	}
	// 	const start = range.start.character + numCharactersStart - numWhiteSpacePreceding < 0 ? 0 : range.start.character + numCharactersStart - numWhiteSpacePreceding;
	// 	const newAnchor = { 
	// 		startLine: range.start.line + numLinesStart, 
	// 		startOffset: start, 
	// 		endLine: range.start.line + numLinesStart,
	// 		endOffset: range.start.character + numCharactersStart + anchor.length + numWhiteSpaceFollowing
	// 	}

	// 	return newAnchor;
	// }

	// if(arr !== -1 && backArr !== -1) {
	// 	const substr = changeText.substring(0, changeText.indexOf(tokenizedAnchor[0]))
	// 	numLinesStart = substr.includes('\n') ? (substr.match(/\n/g) || []).length : 0;
	// 	const lineIndex = numLinesStart ? substr.lastIndexOf('\n') : 0;
	// 	for(let i = lineIndex; i < substr.length - lineIndex; i++) {
	// 		switch(substr[i]) {
	// 			case ('\t'):
	// 				numCharactersStart += tabSize; // may need to get tab size from vscode somehow
	// 				break;
	// 			case ('\r'):
	// 				break;
	// 			default:
	// 				numCharactersStart++;
	// 				break;
	// 		}
	// 	}

	// 	// start of anchor should be {startLine: range.start.line + numLines, startOffset: numCharacters}

	// 	const backSubstr = anchor.includes('\n') ? anchor.substring(anchor.indexOf('\n')) : anchor;

	// 	const backLineIndex = anchor.includes('\n') ? backSubstr.lastIndexOf('\n') : 0;
	// 	const endOfAnchor = backSubstr.substring(backLineIndex + 1);

	// 	// now compare end of anchor to changeText to find where this occurs
	// 	const changeTextByNewline = changeText.split('\n').reverse();
	// 	const num = changeTextByNewline.findIndex((token: string) => token === endOfAnchor || token.includes(endOfAnchor));
	// 	let anchorEnd = 0;
	// 	if(num !== -1) {
	// 		const index = changeTextByNewline[num].indexOf(endOfAnchor);
	// 		anchorEnd = index + endOfAnchor.length;
	// 	}

	// 	for(let i = 0; i < anchorEnd; i++) {
	// 		switch(changeTextByNewline[num][i]) {
	// 			case ('\t'):
	// 				numCharactersEnd += tabSize; // may need to get tab size from vscode somehow
	// 				break;
	// 			case ('\r'):
	// 				break;
	// 			default:
	// 				numCharactersEnd++;
	// 				break;
	// 		}
	// 	}
	// }

	// const start = range.start.character + numCharactersStart - numWhiteSpacePreceding < 0 ? 0 : range.start.character + numCharactersStart - numWhiteSpacePreceding;
	// // console.log('start?', start, 'comp', range.start.character + numCharactersStart - numWhiteSpacePreceding)
	// const newAnchor = { 
	// 	startLine: range.start.line + numLinesStart, 
	// 	startOffset: start, 
	// 	endLine: range.start.line + anchorLength + numLinesStart,
	// 	endOffset: numCharactersEnd + numWhiteSpaceFollowing
	// }

	// // console.log('built this range', newAnchor)

	// return newAnchor;
}

export const translateChanges = (originalStartLine: number, originalEndLine: number, originalStartOffset: number, 
	originalEndOffset: number, startLine: number, endLine: number, startOffset: number, 
	endOffset: number, textLength: number, diff: number, rangeLength: number, 
	anchorText: string, annotation: string, filename: string, visiblePath: string, id: string, createdTimestamp: number, html: string, doc: vscode.TextDocument, changeText: string): Annotation => {
		let newRange = { startLine: originalStartLine, endLine: originalEndLine, startOffset: originalStartOffset, endOffset: originalEndOffset };
		const startAndEndLineAreSame = originalStartLine === startLine && originalEndLine === endLine && !diff;
		const originalRange = new vscode.Range(new vscode.Position(originalStartLine, originalStartOffset), new vscode.Position(originalEndLine, originalEndOffset));
		const changeRange = new vscode.Range(new vscode.Position(startLine, startOffset), new vscode.Position(endLine, endOffset)); 
		// console.log('original range', originalRange);
		// console.log('change range', changeRange);
		// console.log('diff', diff);

		// user deleted the anchor
		if(!textLength && changeRange.contains(originalRange)) {
			const newAnno = {
				id,
				filename,
				visiblePath,
				anchorText,
				annotation,
				...newRange,
				deleted: true,
				html,
				authorId : user?.uid,
				createdTimestamp: new Date().getTime(),
				programmingLang: filename.split('.')[1]
			}
			const deletedAnno = buildAnnotation(newAnno);
			setDeletedAnnotationList(deletedAnnotations.concat([deletedAnno]));
			addHighlightsToEditor(annotationList.filter(a => a.id !== deletedAnno.id));
			return deletedAnno;
		}

		let changeOccurredInRange : boolean = false;

		// user added lines above start of range
		if (originalStartLine > startLine && diff) {
			console.log('above')
			newRange.startLine = originalStartLine + diff;
			newRange.endLine = originalEndLine + diff;
		}
		 // user added line after start and before end
		 // need to update anchor text ?
		if (originalStartLine === startLine && originalStartOffset <= startOffset && diff) {
			console.log('in range')
			newRange.endLine = originalEndLine + diff;
			changeOccurredInRange = true;
		}

		// user added line before the end of the offset so we add a line
		// need to update anchor text
		if (originalEndLine === endLine && originalEndOffset >= endOffset && diff) {
			newRange.endLine = originalEndLine + diff;
			// user removed line -- start of new range should be at the end of our new range
			if(diff < 0) {
				newRange.endOffset = startOffset + originalEndOffset;
			}
			changeOccurredInRange = true;
		}
		// user made change before our start offset
		if (originalStartLine === startLine && startOffset < originalStartOffset) {
			newRange.startOffset = textLength ? originalStartOffset + textLength : originalStartOffset - rangeLength;
			// if end is on the same line we need to update it too
			if(startAndEndLineAreSame) {
				newRange.endOffset = textLength ? originalEndOffset + textLength : originalEndOffset - rangeLength;
			}
		}
		// user made change before or at our end offset -- need to update anchor text
		if(originalEndLine === endLine && endOffset <= originalEndOffset && !diff) {
			// console.log('end offset')
			newRange.endOffset = textLength ? originalEndOffset + textLength : originalEndOffset - rangeLength;
			changeOccurredInRange = true;
		}
		// user inserted text at our end offset () -- need to update anchor text
		if(originalEndLine === endLine && endOffset === (originalEndOffset + textLength) && !diff) {
			// console.log ('text insertion at end offset')
			newRange.endOffset += textLength;
			changeOccurredInRange = true;
		}
		// user added lines between start and end (? not sure why we have this and the second condition)
		// need to update anchor text
		if(originalStartLine < startLine && endLine < originalEndLine && diff) {
			// console.log('insertion between start and end -- this was being flagged during weird situations so should watch out');
			newRange.endLine = originalEndLine + diff;
			changeOccurredInRange = true;
		}



		const newAnno = {
			id,
			filename,
			visiblePath,
			anchorText,
			annotation,
			...newRange,
			deleted: false,
			html,
			authorId : user?.uid,
			createdTimestamp,
			programmingLang: filename.split('.')[1]
		}
		return buildAnnotation(newAnno)

	}

export function createRangeFromAnnotation(annotation: Annotation) : vscode.Range {
	return new vscode.Range(new vscode.Position(annotation.startLine, annotation.startOffset), new vscode.Position(annotation.endLine, annotation.endOffset))
}

export function createRangeFromObject(obj: {[key: string] : any}) : vscode.Range {
	return new vscode.Range(obj.startLine, obj.startOffset, obj.endLine, obj.endOffset);
}

export const addHighlightsToEditor = (annotationList: Annotation[], text: vscode.TextEditor | undefined = undefined) : void => {
	const filenames = [... new Set(annotationList.map(a => a.filename))];
	const visibleEditors = vscode.window.visibleTextEditors.filter((t: vscode.TextEditor) => filenames.includes(t.document.uri.toString()));
	// we have one specific doc we want to highlight
	if(annotationList.length && text && filenames.includes(text.document.uri.toString())) {
		let ranges = annotationList
			.map(a => { return {annotation: a.annotation, filename: a.filename, range: createRangeFromAnnotation(a)}})
			.filter(r => r.filename === text?.document.uri.toString())
			.map(a => { return {annotation: a.annotation, range: a.range }});
		if(ranges.length) {
			try {
				const decorationOptions: vscode.DecorationOptions[] = ranges.map(r => { return { range: r.range, hoverMessage: r.annotation } });
				text.setDecorations(annotationDecorations, decorationOptions);
			}
			catch (error) {
				console.log('couldnt highlight', error);
			}
		} 
	}

	// we want to highlight anything relevant
	else if(!text && visibleEditors.length) {
		const visFiles = visibleEditors.map((t: vscode.TextEditor) => t.document.uri.toString());
		const relevantAnnos = annotationList.filter((a: Annotation) => visFiles.includes(a.filename.toString()));
		const annoDecorationOptions: vscode.DecorationOptions[] = relevantAnnos.map((a: Annotation) => { return { hoverMessage: a.annotation, range: createRangeFromAnnotation(a) } });
		visibleEditors.forEach((v: vscode.TextEditor) => {
			v.setDecorations(annotationDecorations, annoDecorationOptions);
		});
	}

	// nothing
	else {
		console.log('nothing to highlight');
	}
}